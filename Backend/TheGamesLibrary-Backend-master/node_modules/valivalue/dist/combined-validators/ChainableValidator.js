"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainableValidator = void 0;
const DefaultErrorFactory_1 = require("../errors/DefaultErrorFactory");
const ValidationOptions_1 = require("../ValidationOptions");
const NumberValidator_1 = require("../validators/NumberValidator");
const ObjectValidator_1 = require("../validators/ObjectValidator");
const StringValidator_1 = require("../validators/StringValidator");
const TimestampValidator_1 = require("../validators/TimestampValidator");
const ValidationReport_1 = require("../validation-result/ValidationReport");
/**
 * The ChainableValidator allows you to call multiple validation methods with only 1 validator object.
 *
 * @class ChainableValidator
 */
class ChainableValidator {
    /**
     * Construct a new ChainableValidator
     *
     * @param {boolean} [throwOnFailure=false] - Should the validator throw directly when a validation failure occurs.
     */
    constructor(throwOnFailure = false) {
        this.throwOnFailure = throwOnFailure;
        this.results = [];
        const validationReportFactory = () => {
            return (value, error) => {
                const validationReport = new ValidationReport_1.ValidationReport(value, error);
                this.add(validationReport);
                return this;
            };
        };
        const validationOptionsFactory = () => {
            return new ValidationOptions_1.ValidationOptions(DefaultErrorFactory_1.defaultErrorFactory, validationReportFactory());
        };
        const objectValidatorOptions = validationOptionsFactory();
        const stringValidatorOptions = validationOptionsFactory();
        const numberValidatorOptions = validationOptionsFactory();
        const timestampValidatorOptions = validationOptionsFactory();
        this.objects = new ObjectValidator_1.ObjectValidator(objectValidatorOptions);
        this.strings = new StringValidator_1.StringValidator(stringValidatorOptions);
        this.numbers = new NumberValidator_1.NumberValidator(numberValidatorOptions);
        this.timestamps = new TimestampValidator_1.TimestampValidator(timestampValidatorOptions);
    }
    add(validationReport) {
        if (this.throwOnFailure && validationReport.isFailure()) {
            validationReport.throw();
        }
        this.results.push(validationReport);
        return this;
    }
    /**
     * Check whether all validations (so far) are successful.
     *
     * @returns {boolean} Indication whether the validations are successful.
     */
    isSuccess() {
        return this.results.every(result => result.isSuccess());
    }
    /**
     * Check whether any validation (so far) is a failure.
     *
     * @returns {boolean} Inidication whether any validation is a failure.
     */
    isFailure() {
        return this.results.some(result => result.isFailure());
    }
    /**
     * Get the list of errors (so far).
     */
    get errors() {
        return this.results
            .filter(result => result.isFailure())
            .map(result => result.error);
    }
    /**
     * In case of any validation failure, throw the first error that occured.
     */
    throw() {
        if (this.isFailure()) {
            throw this.errors[0];
        }
    }
}
exports.ChainableValidator = ChainableValidator;
