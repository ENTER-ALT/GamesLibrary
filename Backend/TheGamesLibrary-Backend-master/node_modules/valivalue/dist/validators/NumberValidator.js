"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberValidator = void 0;
const ErrorMessageFactory_1 = require("../error-messages/ErrorMessageFactory");
const AbstractValidator_1 = require("./AbstractValidator");
const { numbers: numberFactories } = ErrorMessageFactory_1.errorMessageFactories;
const DEFAULT_SUBJECT = 'Number';
/**
 * The NumberValidator is a validator that contains methods to validate values of type number.
 *
 * @class NumberValidator<OutputType>
 */
class NumberValidator extends AbstractValidator_1.AbstractValidator {
    /**
     * Validate whether the provided value is equal or larger than the provided minimum value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} min - The lower bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMinValue(value, min, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateMinValue) {
        return this.handle(value, value < min, () => errorMessageFactory(subject, value, min));
    }
    /**
     * Validate whether the provided value is equal or smaller than the provided maximum value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} max - The upper bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMaxValue(value, max, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateMaxValue) {
        return this.handle(value, value > max, () => errorMessageFactory(subject, value, max));
    }
    /**
     * Validate whether the provided value is equal or larger than the provided minimum value, and equal or smaller than the provided maximum value.
     * @param {number} value - The value to be validated.
     * @param {number} min - The lower bound (inclusive).
     * @param {number} max - The upper bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMinAndMaxValue(value, min, max, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateMinAndMaxValue) {
        return this.handle(value, value < min || value > max, () => errorMessageFactory(subject, value, min, max));
    }
    /**
     * Validate whether the provided value is a positive number.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsPositive(value, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsPositive) {
        return this.handle(value, value < 0, () => errorMessageFactory(subject, value));
    }
    /**
     * Validate whether the provided value is a negative number.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsNegative(value, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsNegative) {
        return this.handle(value, value >= 0, () => errorMessageFactory(subject, value));
    }
    /**
     * Validate whether the provided value is divisible by the second provided value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} divisibleBy - The number that the validated value should be divisible by.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
  
     */
    validateIsDivisibleBy(value, divisibleBy, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsDivisibleBy) {
        return this.handle(value, value % divisibleBy !== 0, () => errorMessageFactory(subject, value, divisibleBy));
    }
    /**
     * Validate whether the provided value is a factor of the second provided value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} factorOf - The factor.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsFactorOf(value, factorOf, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsFactorOf) {
        return this.handle(value, factorOf % value !== 0, () => errorMessageFactory(subject, value, factorOf));
    }
    /**
     * Validate whether the provided value is even.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsEven(value, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsEven) {
        return this.handle(value, value % 2 !== 0, () => errorMessageFactory(subject, value));
    }
    /**
     * Validate whether the provided value is odd.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsOdd(value, subject = DEFAULT_SUBJECT, errorMessageFactory = numberFactories.validateIsOdd) {
        return this.handle(value, value % 2 === 0, () => errorMessageFactory(subject, value));
    }
}
exports.NumberValidator = NumberValidator;
