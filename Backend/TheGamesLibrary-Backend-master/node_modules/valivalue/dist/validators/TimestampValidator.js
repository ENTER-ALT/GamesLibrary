"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampValidator = void 0;
const luxon_1 = require("luxon");
const AbstractValidator_1 = require("./AbstractValidator");
const ErrorMessageFactory_1 = require("../error-messages/ErrorMessageFactory");
const { timestamps: timestampFactories } = ErrorMessageFactory_1.errorMessageFactories;
const DEFAULT_SUBJECT = 'Timestamp';
/**
 * The TimestampValidator is a validator that contains methods to validate values of type luxon DateTime.
 *
 * @class TimestampValidator<OutputType>
 */
class TimestampValidator extends AbstractValidator_1.AbstractValidator {
    /**
     * Validate whether the supplied timestamp is after the supplied minimum timestamp.
     *
     * @param {DateTime} value - The value to be validated.
     * @param {DateTime} isAfter - The lower bound.
     * @param {string} [subject=Timestamp] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsAfter(value, isAfter, subject = DEFAULT_SUBJECT, errorMessageFactory = timestampFactories.validateIsAfter) {
        return this.handle(value, value.toMillis() < isAfter.toMillis(), () => errorMessageFactory(subject, value, isAfter));
    }
    /**
     * Validate whether the supplied timestamp is before the supplied maximum timestamp.
     *
     * @param {DateTime} value - The value to be validated.
     * @param {DateTime} isBefore - The upper bound.
     * @param {string} [subject=Timestamp] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsBefore(value, isBefore, subject = DEFAULT_SUBJECT, errorMessageFactory = timestampFactories.validateIsBefore) {
        return this.handle(value, value.toMillis() > isBefore.toMillis(), () => errorMessageFactory(subject, value, isBefore));
    }
    /**
     * Validate whether the supplied timestamp is in the past.
     *
     * @param {DateTime} value - The value to be validated.
     * @param {string} [subject=Timestamp] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsInPast(value, subject = DEFAULT_SUBJECT, errorMessageFactory = timestampFactories.validateIsInPast) {
        return this.handle(value, value.toMillis() > luxon_1.DateTime.now().toMillis(), () => errorMessageFactory(subject, value));
    }
    /**
     * Validate whether the supplied timestamp is in the future.
     *
     * @param {DateTime} value - The value to be validated.
     * @param {string} [subject=Timestamp] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsInFuture(value, subject = DEFAULT_SUBJECT, errorMessageFactory = timestampFactories.validateIsInFuture) {
        return this.handle(value, value.toMillis() < luxon_1.DateTime.now().toMillis(), () => errorMessageFactory(subject, value));
    }
}
exports.TimestampValidator = TimestampValidator;
