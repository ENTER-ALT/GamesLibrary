import { AbstractValidator } from "./AbstractValidator";
/**
 * The NumberValidator is a validator that contains methods to validate values of type number.
 *
 * @class NumberValidator<OutputType>
 */
export declare class NumberValidator<OutputType> extends AbstractValidator<number, OutputType> {
    /**
     * Validate whether the provided value is equal or larger than the provided minimum value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} min - The lower bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMinValue(value: number, min: number, subject?: string, errorMessageFactory?: (subject: string, value: number, min: number) => string): OutputType;
    /**
     * Validate whether the provided value is equal or smaller than the provided maximum value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} max - The upper bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMaxValue(value: number, max: number, subject?: string, errorMessageFactory?: (subject: string, value: number, max: number) => string): OutputType;
    /**
     * Validate whether the provided value is equal or larger than the provided minimum value, and equal or smaller than the provided maximum value.
     * @param {number} value - The value to be validated.
     * @param {number} min - The lower bound (inclusive).
     * @param {number} max - The upper bound (inclusive).
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateMinAndMaxValue(value: number, min: number, max: number, subject?: string, errorMessageFactory?: (subject: string, value: number, min: number, max: number) => string): OutputType;
    /**
     * Validate whether the provided value is a positive number.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsPositive(value: number, subject?: string, errorMessageFactory?: (subject: string, value: number) => string): OutputType;
    /**
     * Validate whether the provided value is a negative number.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsNegative(value: number, subject?: string, errorMessageFactory?: (subject: string, value: number) => string): OutputType;
    /**
     * Validate whether the provided value is divisible by the second provided value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} divisibleBy - The number that the validated value should be divisible by.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
  
     */
    validateIsDivisibleBy(value: number, divisibleBy: number, subject?: string, errorMessageFactory?: (subject: string, value: number, divisibleBy: number) => string): OutputType;
    /**
     * Validate whether the provided value is a factor of the second provided value.
     *
     * @param {number} value - The value to be validated.
     * @param {number} factorOf - The factor.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsFactorOf(value: number, factorOf: number, subject?: string, errorMessageFactory?: (subject: string, value: number, factorOf: number) => string): OutputType;
    /**
     * Validate whether the provided value is even.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsEven(value: number, subject?: string, errorMessageFactory?: (subject: string, value: number) => string): OutputType;
    /**
     * Validate whether the provided value is odd.
     *
     * @param {number} value - The value to be validated.
     * @param {string} [subject=Number] - The subject being validated, which will be used in the errorMessageFactory.
     * @param errorMessageFactory - The errorMessageFactory that will be used to construct an error message in case of validation failure.
     * @returns {OutputType} The result of the validation.
     */
    validateIsOdd(value: number, subject?: string, errorMessageFactory?: (subject: string, value: number) => string): OutputType;
}
