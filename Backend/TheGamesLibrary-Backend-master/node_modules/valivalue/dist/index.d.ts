import { ChainableValidator } from "./combined-validators/ChainableValidator";
import { throwingValidator } from "./combined-validators/ThrowingValidator";
/**
 * The reporting validator does not throw on failed validation, but returns a ValidationReport which holds the result.
 */
export declare const reporting: {
    objects: import("./validators/ObjectValidator").ObjectValidator<unknown, import("./validation-result/ValidationReport").ValidationReport<unknown>>;
    strings: import("./validators/StringValidator").StringValidator<import("./validation-result/ValidationReport").ValidationReport<string>>;
    numbers: import("./validators/NumberValidator").NumberValidator<import("./validation-result/ValidationReport").ValidationReport<number>>;
    timestamps: import("./validators/TimestampValidator").TimestampValidator<import("./validation-result/ValidationReport").ValidationReport<import("luxon").DateTime>>;
};
/**
 * The chainable validator can always returns itself, so you can chain validation methods.
 *
 * @param {boolean} [throwOnFailure=false] - Whether the validator should throw directly on failed validation.
 * @returns {ChainableValidator} The created chainable validator.
 */
export declare const chainable: (throwOnFailure?: boolean) => ChainableValidator;
/**
 * The throwing validator throws directly on failed validation.
 */
export default throwingValidator;
